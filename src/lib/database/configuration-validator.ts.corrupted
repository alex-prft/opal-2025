/**\n * Configuration Validation Middleware for OSA Supabase Operations\n * \n * This middleware enforces data governance policies, validates configurations,\n * and ensures compliance with OSA's data handling requirements.\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport { supabaseGuardrails, DataClassification } from './supabase-guardrails';\nimport { auditSystem } from './audit-system';\nimport { dataRetentionManager } from './data-retention-manager';\n\n/**\n * Configuration schemas for different data types\n */\nexport const OSAConfigSchemas = {\n  // OPAL agent configurations\n  opal_agent: z.object({\n    name: z.string().min(1).max(100),\n    type: z.enum(['content', 'strategy', 'analytics', 'recommendations']),\n    configuration: z.object({\n      model: z.string().optional(),\n      parameters: z.record(z.any()).optional(),\n      endpoints: z.array(z.string().url()).optional(),\n      rate_limits: z.object({\n        requests_per_minute: z.number().min(1).max(1000),\n        concurrent_requests: z.number().min(1).max(10)\n      }).optional()\n    }),\n    enabled: z.boolean(),\n    metadata: z.record(z.any()).optional()\n  }),\n  \n  // System settings\n  system_setting: z.object({\n    key: z.string().regex(/^[a-z_]+$/),\n    value: z.union([z.string(), z.number(), z.boolean(), z.object({})]),\n    category: z.enum(['security', 'performance', 'ui', 'integration']),\n    requires_restart: z.boolean().optional(),\n    validation_rule: z.string().optional()\n  }),\n  \n  // User preferences (non-PII)\n  user_preference: z.object({\n    theme: z.enum(['light', 'dark', 'auto']).optional(),\n    dashboard_layout: z.array(z.string()).optional(),\n    notification_preferences: z.object({\n      email: z.boolean().optional(),\n      in_app: z.boolean().optional(),\n      frequency: z.enum(['immediate', 'daily', 'weekly']).optional()\n    }).optional(),\n    language: z.string().length(2).optional(),\n    timezone: z.string().optional()\n  }),\n  \n  // Workflow metadata\n  workflow_metadata: z.object({\n    workflow_type: z.enum(['personalization', 'optimization', 'analysis']),\n    industry_category: z.string().optional(),\n    complexity_score: z.number().min(1).max(10).optional(),\n    estimated_duration_hours: z.number().min(0.1).max(168).optional(),\n    required_integrations: z.array(z.string()).optional(),\n    anonymized: z.boolean().default(false)\n  }),\n  \n  // Anonymous metrics\n  anonymous_metric: z.object({\n    metric_type: z.enum(['usage', 'performance', 'error', 'feature_adoption']),\n    aggregation_level: z.enum(['hourly', 'daily', 'weekly', 'monthly']),\n    dimensions: z.record(z.string()).optional(),\n    value: z.number(),\n    count: z.number().optional(),\n    timestamp: z.string().datetime()\n  })\n};\n\n/**\n * Allowed tables for each configuration type\n */\nexport const CONFIGURATION_TABLE_MAPPING = {\n  opal_agent: ['opal_agent_configs', 'opal_tool_registry'],\n  system_setting: ['system_settings', 'opal_configurations'],\n  user_preference: ['user_preferences'],\n  workflow_metadata: ['opal_workflow_executions', 'workflow_metadata'],\n  anonymous_metric: ['anonymous_usage_metrics', 'performance_analytics']\n};\n\n/**\n * Restricted operations by table\n */\nexport const TABLE_RESTRICTIONS = {\n  // Customer data tables - completely blocked\n  customer_data: { operations: [], reason: 'Customer data must not be stored in Supabase' },\n  personal_info: { operations: [], reason: 'PII data must not be stored in Supabase' },\n  crm_leads: { operations: [], reason: 'CRM data should be processed, not persisted' },\n  \n  // Configuration tables - full access\n  opal_configurations: { operations: ['read', 'write', 'update'], classification: 'configuration' },\n  opal_agent_configs: { operations: ['read', 'write', 'update'], classification: 'configuration' },\n  system_settings: { operations: ['read', 'write', 'update'], classification: 'configuration' },\n  \n  // Metadata tables - limited operations\n  opal_workflow_executions: { operations: ['read', 'write'], classification: 'metadata' },\n  opal_agent_executions: { operations: ['read', 'write'], classification: 'metadata' },\n  \n  // Temporary tables - auto-cleanup\n  session_states: { operations: ['read', 'write', 'delete'], classification: 'temporary' },\n  temporary_workflow_data: { operations: ['read', 'write', 'delete'], classification: 'temporary' },\n  \n  // Audit tables - write-only for most operations\n  supabase_audit_log: { operations: ['read', 'write'], classification: 'metadata' },\n  compliance_reports: { operations: ['read', 'write'], classification: 'metadata' }\n};\n\nexport interface ValidationContext {\n  table: string;\n  operation: 'read' | 'write' | 'update' | 'delete';\n  data?: any;\n  userContext?: {\n    sessionId?: string;\n    ipAddress?: string;\n    userAgent?: string;\n    requestId?: string;\n  };\n  bypassValidation?: boolean;\n}\n\nexport interface ValidationResult {\n  allowed: boolean;\n  reason?: string;\n  sanitizedData?: any;\n  warnings?: string[];\n  classification?: DataClassification;\n  auditRequired: boolean;\n}\n\nexport class ConfigurationValidator {\n  \n  /**\n   * Main validation entry point\n   */\n  async validateOperation(context: ValidationContext): Promise<ValidationResult> {\n    const startTime = performance.now();\n    \n    try {\n      // Check if bypass is requested (admin operations)\n      if (context.bypassValidation) {\n        await this.logBypassUsage(context);\n        return {\n          allowed: true,\n          reason: 'Validation bypassed',\n          classification: this.classifyTable(context.table),\n          auditRequired: true\n        };\n      }\n      \n      // Check table restrictions\n      const tableRestriction = TABLE_RESTRICTIONS[context.table as keyof typeof TABLE_RESTRICTIONS];\n      if (tableRestriction && !tableRestriction.operations.includes(context.operation)) {\n        return {\n          allowed: false,\n          reason: tableRestriction.reason || `Operation ${context.operation} not allowed on ${context.table}`,\n          auditRequired: true\n        };\n      }\n      \n      // Determine data classification\n      const classification = this.classifyTable(context.table);\n      \n      // Validate using guardrails system\n      const guardrailsResult = await supabaseGuardrails.validateDataOperation(\n        context.table,\n        context.operation,\n        context.data,\n        classification\n      );\n      \n      if (!guardrailsResult.allowed) {\n        return {\n          allowed: false,\n          reason: guardrailsResult.reason,\n          classification,\n          auditRequired: true\n        };\n      }\n      \n      // Validate configuration schema if writing data\n      const warnings: string[] = [];\n      let sanitizedData = context.data;\n      \n      if (context.operation === 'write' || context.operation === 'update') {\n        const schemaValidation = await this.validateConfigurationSchema(\n          context.table,\n          context.data\n        );\n        \n        if (!schemaValidation.valid) {\n          return {\n            allowed: false,\n            reason: `Schema validation failed: ${schemaValidation.errors.join(', ')}`,\n            classification,\n            auditRequired: true\n          };\n        }\n        \n        sanitizedData = schemaValidation.sanitizedData;\n        warnings.push(...schemaValidation.warnings);\n      }\n      \n      // Session token handling\n      if (context.table === 'session_states') {\n        sanitizedData = this.handleSessionTokens(sanitizedData);\n      }\n      \n      // A/B testing configuration validation\n      if (context.table === 'ab_test_configurations') {\n        const abValidation = this.validateABTestConfig(sanitizedData);\n        if (!abValidation.valid) {\n          warnings.push(...abValidation.warnings);\n        }\n      }\n      \n      // Log successful validation\n      const duration = performance.now() - startTime;\n      await auditSystem.logDatabaseOperation({\n        table: context.table,\n        operation: context.operation,\n        duration_ms: duration,\n        classification,\n        userContext: context.userContext,\n        success: true\n      });\n      \n      return {\n        allowed: true,\n        sanitizedData,\n        warnings,\n        classification,\n        auditRequired: true\n      };\n      \n    } catch (error) {\n      const duration = performance.now() - startTime;\n      \n      await auditSystem.logDatabaseOperation({\n        table: context.table,\n        operation: context.operation,\n        duration_ms: duration,\n        userContext: context.userContext,\n        success: false,\n        errorMessage: error instanceof Error ? error.message : 'Unknown error'\n      });\n      \n      return {\n        allowed: false,\n        reason: `Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        auditRequired: true\n      };\n    }\n  }\n  \n  /**\n   * Validate configuration against schema\n   */\n  private async validateConfigurationSchema(table: string, data: any): Promise<{\n    valid: boolean;\n    errors: string[];\n    warnings: string[];\n    sanitizedData?: any;\n  }> {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    \n    try {\n      // Determine configuration type based on table\n      const configType = this.getConfigurationType(table);\n      \n      if (!configType) {\n        // No specific schema validation required\n        return {\n          valid: true,\n          errors: [],\n          warnings: [],\n          sanitizedData: data\n        };\n      }\n      \n      const schema = OSAConfigSchemas[configType];\n      if (!schema) {\n        warnings.push(`No schema defined for configuration type: ${configType}`);\n        return {\n          valid: true,\n          errors: [],\n          warnings,\n          sanitizedData: data\n        };\n      }\n      \n      // Validate against schema\n      const result = schema.safeParse(data);\n      \n      if (!result.success) {\n        result.error.issues.forEach(issue => {\n          errors.push(`${issue.path.join('.')}: ${issue.message}`);\n        });\n        \n        return {\n          valid: false,\n          errors,\n          warnings\n        };\n      }\n      \n      return {\n        valid: true,\n        errors: [],\n        warnings,\n        sanitizedData: result.data\n      };\n      \n    } catch (error) {\n      errors.push(`Schema validation error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      return {\n        valid: false,\n        errors,\n        warnings\n      };\n    }\n  }\n  \n  /**\n   * Handle session tokens with automatic expiration\n   */\n  private handleSessionTokens(data: any): any {\n    if (!data) return data;\n    \n    // Auto-set expiration if not provided\n    if (!data.expires_at) {\n      const expiresAt = new Date();\n      expiresAt.setHours(expiresAt.getHours() + 24); // 24-hour default\n      data.expires_at = expiresAt.toISOString();\n    }\n    \n    // Ensure token is encrypted/hashed (implementation depends on security requirements)\n    if (data.token && typeof data.token === 'string' && !data.token.startsWith('encrypted:')) {\n      // In production, implement proper encryption\n      data.token = `encrypted:${Buffer.from(data.token).toString('base64')}`;\n    }\n    \n    return data;\n  }\n  \n  /**\n   * Validate A/B testing configurations\n   */\n  private validateABTestConfig(data: any): {\n    valid: boolean;\n    warnings: string[];\n  } {\n    const warnings: string[] = [];\n    \n    if (!data) return { valid: true, warnings };\n    \n    // Check for indirect customer references\n    if (data.targeting_rules) {\n      const rules = JSON.stringify(data.targeting_rules);\n      if (rules.includes('email') || rules.includes('phone') || rules.includes('address')) {\n        warnings.push('A/B test targeting rules may contain PII references');\n      }\n    }\n    \n    // Ensure audience segments are anonymized\n    if (data.audience_segments) {\n      data.audience_segments.forEach((segment: any, index: number) => {\n        if (segment.name && segment.name.includes('@')) {\n          warnings.push(`Audience segment ${index + 1} name appears to contain email`);\n        }\n      });\n    }\n    \n    return { valid: true, warnings };\n  }\n  \n  /**\n   * Classify table based on naming patterns\n   */\n  private classifyTable(table: string): DataClassification {\n    if (table.includes('config') || table.includes('settings') || table.includes('preference')) {\n      return 'configuration';\n    }\n    if (table.includes('metric') || table.includes('analytics') || table.includes('anonymous')) {\n      return 'anonymous_metrics';\n    }\n    if (table.includes('session') || table.includes('temporary') || table.includes('cache')) {\n      return 'temporary';\n    }\n    if (table.includes('audit') || table.includes('log') || table.includes('execution')) {\n      return 'metadata';\n    }\n    \n    return 'metadata'; // Default to metadata for unknown tables\n  }\n  \n  /**\n   * Get configuration type from table name\n   */\n  private getConfigurationType(table: string): keyof typeof OSAConfigSchemas | null {\n    for (const [configType, tables] of Object.entries(CONFIGURATION_TABLE_MAPPING)) {\n      if (tables.includes(table)) {\n        return configType as keyof typeof OSAConfigSchemas;\n      }\n    }\n    return null;\n  }\n  \n  /**\n   * Log bypass validation usage for audit\n   */\n  private async logBypassUsage(context: ValidationContext): Promise<void> {\n    await auditSystem.logSecurityEvent({\n      type: 'unauthorized_access',\n      details: {\n        event: 'validation_bypassed',\n        table: context.table,\n        operation: context.operation,\n        reason: 'Administrative bypass requested'\n      },\n      userContext: context.userContext,\n      severity: 'medium'\n    });\n  }\n}\n\n/**\n * Middleware function for Next.js API routes\n */\nexport function createSupabaseValidationMiddleware() {\n  const validator = new ConfigurationValidator();\n  \n  return async function middleware(req: NextRequest) {\n    // Extract operation details from request\n    const userContext = {\n      sessionId: req.headers.get('x-session-id') || undefined,\n      ipAddress: req.headers.get('x-forwarded-for') || req.headers.get('x-real-ip') || undefined,\n      userAgent: req.headers.get('user-agent') || undefined,\n      requestId: req.headers.get('x-request-id') || undefined\n    };\n    \n    // Attach validation to request for use in API routes\n    (req as any).validateSupabaseOperation = async (context: Omit<ValidationContext, 'userContext'>) => {\n      return validator.validateOperation({\n        ...context,\n        userContext\n      });\n    };\n    \n    return NextResponse.next();\n  };\n}\n\n/**\n * Scheduled task to run data retention policies\n */\nexport async function runScheduledRetention(): Promise<void> {\n  try {\n    console.log('Starting scheduled data retention execution...');\n    \n    const result = await dataRetentionManager.executeRetentionPolicies(false);\n    \n    await auditSystem.logEvent({\n      event_type: 'DATA_RETENTION',\n      details: {\n        execution_id: result.executionId,\n        total_records_affected: result.totalRecordsAffected,\n        duration_ms: result.totalDuration,\n        errors: result.errors\n      },\n      severity: result.errors.length > 0 ? 'medium' : 'low',\n      status: result.errors.length === 0 ? 'success' : 'warning'\n    });\n    \n    console.log(`Scheduled retention completed: ${result.totalRecordsAffected} records processed`);\n    \n  } catch (error) {\n    console.error('Scheduled retention failed:', error);\n    \n    await auditSystem.logEvent({\n      event_type: 'DATA_RETENTION',\n      details: {\n        error: error instanceof Error ? error.message : 'Unknown error',\n        scheduled_execution: true\n      },\n      severity: 'high',\n      status: 'failure'\n    });\n  }\n}\n\n// Export singleton instance\nexport const configurationValidator = new ConfigurationValidator();